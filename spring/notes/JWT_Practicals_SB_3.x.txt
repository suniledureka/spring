JWT Application

Getting Started with JWT

Basic Authentication
  - No Expiration Time
  - No User Details - what authorizations does a user have
  - Easily Decoded

How about a custom token system?
  - Custom Structure
  - Possible Security Flaws
  - Service Provider & Service Consumer should understand

JWT (Json Web Token)
  - Open, industry standard for representing claims securely between two parties
  - Can Contain User Details and Authorizations


---------------------------------------------------------------------------
What does a JWT contain?

Header
  Type: JWT
  Hashing Algorithm: HS512

Payload
  Standard Attributes
   iss: The issuer
   sub: The subject - about whom this token about
   aud: The audience
   exp: When does token expire?
   iat: When was token issued?

  Custom Attributes
   youratt1: Your custom attribute 1

Signature
  Includes a Secret
  combination base64 encoded value of header, base64 encoded value of payload and your secret, all of these are hashed and is a part of signature of JT

jwt.io

In your JWTs we can make use of keys to encrypt and to decrypt
wheneven we tak about encryption - there are two types of encryption
1) Symmetric Key Encryption
Symmetric encryption algorithms use the same key for encryption algorithm and for decryption algorithm 
plain text is converted to secret text or cypher text by the encryption algorithm  using the data encryption key and to decrypt from cypher text to plain text, we need the same data encryption key again

Key Factor 1: Choose the right encryption algorithm
Key Factor 2: How do we secure the encryption key? - no one should get access
Key Factor 3: How do we share the encryption key?

2) Asymmetric Key Encryption

 Two Keys : Public Key and Private Key
 Also called Public Key Cyptography
 Encrypt data with Public Key and decrypt with Private Key
 Share Public Key with everybody and
 keep the Private Key with you
No crazy questions:
 Will somebody not figure out private key using the public key?
Best Practice: Use Asymmetric Keys


Understanding High Level JWT Flow

1: Create a JWT
 Needs Encoding
  1: User credentials
  2: User data (payload)
  3: RSA key pair
  We will create a JWT Resource for creating JWT later

2: Send JWT as part of request header
     Authorization Header
     Bearer Token
     Authorization: Bearer ${JWT_TOKEN}

3: JWT is verified
     Needs Decoding
     RSA key pair (Public Key)



JWT Security Configuration

JWT Authentication using Spring Boot's OAuth2 Resource Server

new dependency - OAuth2 Resource Server (spring-boot-starter-oauth2-resource-server)

- Comment out Basic Auth Configuration //@Configuration - to disable basic security configuration

-create a new class JwtSecurityConfiguration

@Configuration
public class JwtSecurityConfiguration {
	@Bean
	public DataSource dataSource() {
	 return new EmbeddedDatabaseBuilder()
			.setType(EmbeddedDatabaseType.H2)
			.addScript(JdbcDaoImpl.DEFAULT_USER_SCHEMA_DDL_LOCATION)
			.build();
	}
	
	@Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
  		http.authorizeHttpRequests(auth -> {
			auth.anyRequest().authenticated();
		});
        
		http.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)); //stateless
		
		http.csrf().disable();
		http.headers().frameOptions().sameOrigin();
		
		http.httpBasic();
		
	--(1)	http.oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt);
		return http.build();        
    }

	@Bean
	public BCryptPasswordEncoder passwordEncoder() {
	 return new BCryptPasswordEncoder();
	}
	
	
	@Bean
	public UserDetailsService userDetailsService(DataSource dataSource) {
	 var user = User.withUsername("sunil")	   
	     .password("12345")
	     .passwordEncoder(str -> passwordEncoder().encode(str))
	     .roles("USER")
	     .build();

	 var admin = User.withUsername("admin")
	     .password("12345")
	     .passwordEncoder(str -> passwordEncoder().encode(str))
	     .roles("ADMIN","USER")
	     .build();

	 var users = new JdbcUserDetailsManager(dataSource);
	 users.createUser(user);
	 users.createUser(admin);
	 return users;
	} 
}


-- run the application - gets an error - 'JwtDecoder' that could not be found.

JWT Authentication using Spring Boot's OAuth2 Resource Server
1: Create Key Pair
    We will use java.security.KeyPairGenerator
    You can use openssl as well

2: Create RSA Key object using Key Pair  com.nimbusds.jose.jwk.RSAKey

3: Create JWKSource (JSON Web Key source)
   Create JWKSet (a new JSON Web Key set) with the RSA Key
   Create JWKSource using the JWKSet

4: Use RSA Public Key for Decoding
   NimbusJwtDecoder.withPublicKey(rsaKey().toRSAPublicKey()).build()
5: Use JWKSource for Encoding
   return new NimbusJwtEncoder(jwkSource());
   We will use this later in the JWT Resource


- Create Key Pair
@Bean
public KeyPair keyPair() {
 try {
   var keyPairGenerator = KeyPairGenerator.getInstance("RSA");
   keyPairGenerator.initialize(2048); //2048 - keysize 2MB RSA Encryption
   return keyPairGenerator.generateKeyPair();
 } catch (Exception ex) {
	throw new RuntimeException(ex);
 }
}

- Create RSA Key object using Key Pair  com.nimbusds.jose.jwk.RSAKey (provided by OAuth2)

@Bean
public RSAKey rsaKey(KeyPair keyPair) { //keyPair bean is autowired
 return new RSAKey.Builder((RSAPublicKey)keyPair.getPublic())
		.privateKey(keyPair.getPrivate())
		.keyID(UUID.randomUUID().toString())
		.build();
}

- Create JWKSource (JSON Web Key source)
 - SecurityContext from nimbus

@Bean
public JWKSource<SecurityContext> jwkSource(RSAKey rsaKey) {
  var jwkSet = new JWKSet(rsaKey);
  /*
  var jwkSource = new JWKSource(){
     @Override
     public List get(JWKSelector jwkSelector, SecurityContext context){
        return jwkSelector.select(jwkSet);
     }
   };
  */
  return (jwkSelector, context) ->  jwkSelector.select(jwkSet);
}

- Use RSA Public Key for Decoding
@Bean
public JwtDecoder jwtDecoder(RSAKey rsaKey) throws JOSEException {
  return NimbusJwtDecoder.withPublicKey(rsaKey.toRSAPublicKey())
			.build();
}

-- run application

Setting up JWT Resource with Spring Security and Spring Boot

-- create an Encoder

@Bean
public JwtEncoder jwtEncoder(JWKSource<SecurityContext> jwkSource) {
 return new NimbusJwtEncoder(jwkSource);
} 

Step 1: Use Basic Authentication for getting the JWT Token
Step 2: Use JWT token as Bearer Token for authenticating Requests

@RestController
public class JwtAuthenticationResource {
 @PostMapping("/authenticate") 
 public Authentication authenticate(Authentication authentication) {
  return authentication;
 }
}

 POST --- http://localhost:8080/autheticate
Authentication (header) - Basic Username & password

-- we can see the Pricipal details as the response


-- now create JWT Token

record JwtResponse(String token) {}

@RestController
public class JwtAuthenticationResource {
 private JwtEncoder jwtEncoder;
	
 public JwtAuthenticationResource(JwtEncoder jwtEncoder) {
   this.jwtEncoder = jwtEncoder;
 }

 @PostMapping("/authenticate") 
 public JwtResponse authenticate(Authentication authentication) {
  //return new JwtResponse("token");
  return new JwtResponse(createToken(authentication));
 }

 private String createToken(Authentication authentication) {
	var claims = JwtClaimsSet.builder()
		.issuer("self")
		.issuedAt(Instant.now())
		.expiresAt(Instant.now().plusSeconds(60 * 30))
		.subject(authentication.getName())
		.claim("scope", createScope(authentication))
		.build();
		
	return jwtEncoder.encode(JwtEncoderParameters.from(claims)).getTokenValue();
  }

 private String createScope(Authentication authentication) {
    return authentication.getAuthorities().stream()
	 .map(a -> a.getAuthority())
	 .collect(Collectors.joining(" "));			
    }
 }

record JwtResponse(String token) {}

run the application and can see the token
